My notes on swiftUI<!--more-->

### SwiftUI Key concepts

- In imperative programming, you write a series of statements to describe how your program works.

- a declarative paradigm, where you state what your program does instead of how it works. This works exceptionally well for building user interfaces,

- User interfaces in SwiftUI are made of view structures
SwiftUI interfaces are made of views. This idea is not new and comes from the MVC pattern. In short, the role of a view is to show information to the user and enable interaction.

- The first is the some keyword in the return type of the body property. That‚Äôs an opaque result type, a feature introduced in Swift 5.1. It allows you to hide the returned value behind the View protocol. All you need to know about opaque types, for now, is that they make it easier to write and change SwiftUI code.

- We can‚Äôt merely put views together in the body property. If you try to list views one after another, the compiler will complain.

- To layout views and compose structured interfaces, you have to use stacks. SwiftUI offers three:
1. HStack for horizontal arrangements,
2. VStack to arrange views vertically, and
3. ZStack, to overlay views in front of each other.

### Steps when building a SwiftUI app:
1. Planning a Paged App
2. Prototyping the Main View
3. Prototyping Supplementary Views
4. Moving Data Between Views
5. Observing Objects
6. Saving Settings
7. Saving History Data
8. Refining Your App
9. Working With Datasets
10. Managing Data With Property Wrappers

```swift
struct Row: View {
	var body: some View {
		HStack() {
			Image("Alita")
			VStack {
				Text("Alita: Battle Angel")
				Text("Robert Rodriguez")
				Text("Action, Adventure, Sci-Fi, Thriller")
				Text("122 min")
			}
		}
	}
}
```

You create previews in code as you do for SwiftUI views. Any time you create a new SwiftUI view file in Xcode, you get the preview code for free in the template. You can then see the result in the Xcode canvas, which you can bring out using the Adjust Editor Options menu.

```swift
// it's a common practice to put preview code in debug fencing:
#if DEBUG
struct Row_Previews: PreviewProvider {
    static var previews: some View {
        Row()
    }
}
#endif
```

 
ref: 




Views that require Bindings
In a chat app, I have a LoginView that updates the username binding that's past from the enclosing view:

```swift
struct LoginView: View {  
   @Binding var username: String
   ...
}
```
The simplest way to create a binding in your preview is to use the constant function:

```swift
struct LoginView_Previews: PreviewProvider {
   static var previews: some View {
       LoginView(username: .constant("Billy"))
   }
}
```
// üèÄ


### A simple tab-bar app:
https://heyjaywilson.medium.com/use-enums-for-tags-in-swiftui-1c3ce349d92c
```swift
import SwiftUI

struct ContentView: View {
   @State private var selection = Tabs.inbox
   
   private enum Tabs: Hashable {
      case inbox
      case projects
      case settings
   }
   
   var body: some View {
      TabView(selection: $selection){
         Text("This will be inbox")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "tray.fill")
                  Text("Inbox")
               }
            }
            .tag(Tabs.inbox)
         Text("This will be projects")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "folder.fill")
                  Text("Projects")
               }
            }
            .tag(Tabs.projects)
         Text("This will be settings")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "gear")
                  Text("Settings")
               }
            }
            .tag(Tabs.settings)
      }
   }
}

struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
      ContentView()
   }
}

```


### Grid

From iOS 16 Grid and GridRow

https://developer.apple.com/documentation/swiftui/grid

and another grid example:   

https://stackoverflow.com/a/77249313

```swift
struct GridTextView: View {
        var rowData: [RowData] = RowData.sample
        var body: some View {
            Grid(alignment: .leading) {
                Text("Some sort of title")
                ForEach(RowData.sample) { row in
                    GridRow {
                        Text(row.id)
                        Text(row.name)
                            .gridCellColumns(2)
                    }
                }
                GridRow {
                    let row = RowData.sample.first!
                    Text(row.id)
                    Text(row.name)
                    Text("Third extra column")
                }
            }
            .padding()
        }
    }
    
    struct RowData: Identifiable {
        var id: String
        var name: String
        static var sample: [Self] = [.init(id: "1", name: "Joe Doe"), .init(id: "10000", name: "Diana Snow")]
    }
```
```swift

Grid {
    GridRow {
        Text("Row 1")
        ForEach(0..<2) { _ in Color.red }
    }
    GridRow {
        Text("Row 2")
        ForEach(0..<5) { _ in Color.green }
    }
    GridRow {
        Text("Row 3")
        ForEach(0..<4) { _ in Color.blue }
    }
}
```

customize the grid: 
```swift
Grid(alignment: .bottom, horizontalSpacing: 1, verticalSpacing: 1) {}
```
Performance considerations
A grid can size its rows and columns correctly because it renders all of its child views immediately. If your app exhibits poor performance when it first displays a large grid that appears inside a ScrollView, consider switching to a LazyVGrid or LazyHGrid instead.

Lazy grids render their cells when SwiftUI needs to display them, rather than all at once. This reduces the initial cost of displaying a large scrollable grid that‚Äôs never fully visible, but also reduces the grid‚Äôs ability to optimally lay out cells. Switch to a lazy grid only if profiling your code shows a worthwhile performance improvement.

https://developer.apple.com/documentation/swiftui/lazyvgrid

```swift
struct VerticalSmileys: View {
    let columns = [GridItem(.flexible()), GridItem(.flexible())]
    var body: some View {
         ScrollView {
             LazyVGrid(columns: columns) {
                 ForEach(0x1f600...0x1f679, id: \.self) { value in
                     Text(String(format: "%x", value))
                     Text(emoji(value))
                         .font(.largeTitle)
                 }
             }
         }
    }
    private func emoji(_ value: Int) -> String {
        guard let scalar = UnicodeScalar(value) else { return "?" }
        return String(Character(scalar))
    }
}
```


### LazyVStack:

https://developer.apple.com/documentation/swiftui/lazyvstack

```swift
ScrollView {
    LazyVStack(alignment: .leading) {
        ForEach(1...100, id: \.self) {
            Text("Row \($0)")
        }
    }
}
// There is also LazyHStack
ScrollView(.horizontal) {
    LazyHStack(alignment: .top, spacing: 10) {
        ForEach(1...100, id: \.self) {
            Text("Column \($0)")
        }
    }
}
```

### Section:
To group content or data inside a lazy stack view, use Section instances as containers for collections of grouped views. Section views don‚Äôt have any visual representation themselves but can contain header and footer views that can either scroll with the stack‚Äôs content or that you can pin to the top or bottom of the ScrollView.

Note

Use Section views to get platform-appropriate grouping inside stack views or lazy stacks, lazy grids, List, CommandMenu, Form, and several other container types.
```swift 
struct ColorData: Identifiable {
    let id = UUID()
    let name: String
    let color: Color
    let variations: [ShadeData]


    struct ShadeData: Identifiable {
        let id = UUID()
        var brightness: Double
    }


    init(color: Color, name: String) {
        self.name = name
        self.color = color
        self.variations = stride(from: 0.0, to: 0.5, by: 0.1)
            .map { ShadeData(brightness: $0) }
    }
}
```
```swift
struct ColorSelectionView: View {
    let sections = [
        ColorData(color: .red, name: "Reds"),
        ColorData(color: .green, name: "Greens"),
        ColorData(color: .blue, name: "Blues")
    ]
    var body: some View {
        ScrollView {
            LazyVStack(spacing: 1) {
                ForEach(sections) { section in
                    Section(header: SectionHeaderView(colorData: section)) {
                        ForEach(section.variations) { variation in
                            section.color
                                .brightness(variation.brightness)
                                .frame(height: 20)
                        }
                    }
                }
            }
        }
    }
}
```

For header and footer view: https://developer.apple.com/documentation/swiftui/grouping-data-with-lazy-stack-views



### Stacks:
Equal height hstacks: https://sarunw.com/posts/swiftui-equal-height-hstack/

### ‚≠ê Sizing in SwiftUI (very important):
- ‚≠ê ideal size / intrinsic size / fixed size: https://sarunw.com/posts/intrinsic-content-size-in-swiftui/
- ‚≠ê FixedSize and ideal size: https://sarunw.com/posts/swiftui-fixedsize/

### Shape:

```swift
Rectangle()
    .fill(Color.pink)
Rectangle()
    .inset(by: 10) // padding
    .fill(Color.pink)
Rectangle()
    .offset(x: 100, y: 100) // offset positioning
    .fill(Color.pink)
Rectangle()
    .scale(0.5)// scale
    .fill(Color.pink)
Rectangle()
    .rotation(.degrees(90)) // rotates the rect
Rectangle()
    // gradient (If you want to rotate the color, use .rotationEffect.)
    .fill(LinearGradient(gradient: Gradient(colors: [.pink, .black]), startPoint: .top, endPoint: .bottom))
Rectangle()
    .stroke(Color.pink)
    .frame(width: 100, height: 100)
Rectangle()
    .stroke(Color.pink, lineWidth: 5)
    .frame(width: 100, height: 100)
Rectangle()
    // draws stroke in the center of rect
    .stroke(Color.pink, style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round))
    .frame(width: 100, height: 100)
Rectangle()
    // within rectange
    .strokeBorder(Color.pink, lineWidth: 20, antialiased: true)
    .frame(width: 100, height: 100)
    .border(Color.blue)
```
More on gradient: https://sarunw.com/posts/gradient-in-swiftui/

### To draw fill and stroke: 
We cant draw and fill in the same rect, because both return view
```swift
ZStack {
    Rectangle()
        .fill(Color.pink)
        .frame(width: 100, height: 100)
    Rectangle()
        .stroke(Color.blue)
        .frame(width: 100, height: 100)
}
Rectangle()
    .fill(Color.pink)
    .frame(width: 100, height: 100)
    .overlay(
        Rectangle()
            .stroke(Color.blue)
)
```

**.trim** 

Draw fractional stroke:

```swift
struct ContentView: View {
    @State private var progress: CGFloat = 0
    
    var body: some View {
        VStack {
            Spacer()
        Rectangle()
            .trim(from: 0, to: progress)
            .stroke(Color.pink)
            .frame(width: 200, height: 200)
        
            Rectangle()
            .trim(from: 0, to: progress)
            .stroke(Color.pink)
            .frame(width: 200, height: 100)
            
            Spacer()
            Text("\(progress)")
            Slider(value: $progress)
        }
    }
}
```

### Font

Using UIFont in swiftUI
```swift
let uiFont = UIFont.systemFont(ofSize: 18, weight: .bold)
// 1
let font = Font(uiFont)
```
Apple encourages us to use built-in text styles whenever possible.
```swift
Text("Hello, world!")
    .font(.largeTitle) //  text style adapts its size based on user text size preference
``` 

There are two ways to set a font size for Text view in SwiftUI.

- Fixed size (Fixed font size stays the same regardless of user preference.) To set fixed font size, we specified the size we wanted at a time when we created a font. We can set this for both the system font and a custom font.
- Dynamic size: Dynamic Type size is a way we describe text size from its usage (text style) instead of the exact point size. Apple has 11 text styles at the moment.
1. Large Title
2. Title 1
3. Title 2
4. Title 3
5. Headline
6. Body
7. Callout
8. Subhead
9. Footnote
10. Caption 1
11. Caption 2


If the text style size doesn't match what your need, you can set a font size by specified when you initialize a font.

Set font size for a system font.
```swift

Text("Hello, world!")
    .font(.system(size: 36))
    
```

Set font size for a custom font. 
```swift
Text("Hello, world!")
    .font(.custom(
        "AmericanTypewriter",
        fixedSize: 36))

```

Note that once you decide to set your font size, you opt out of the benefits of text style automatic sizing based on user prefs. It is possible make relative fontsize: You can also set a size for custom font relative to text style with Font.custom(_:size:). https://sarunw.com/posts/how-to-change-swiftui-font-size/

```swift
Text("Hello, world!")
    .font(.system(.largeTitle, design: .rounded))
If you initialize a fixed-size font, you can set the font design like this:

Text("Hello, world!")
    .font(.system(size: 34, design: .rounded))
``` 

Set font-weight with font initializer

You can set this when you initialize a custom system font.

```swift
Text("Hello, world!")
    .font(
        .system(size: 34, weight: .bold)
    )
```

Set font-weight with fontWeight(_:) modifier

Text view also has a way to modify font-weight. You can set it with fontWeight(_:) modifier.

Since it is a Text instance method, we use this on a text, not a font.

```swift
Text("Hello, world!")
    .font(
        .system(size: 34)
    )
    .fontWeight(.bold)
    
```


Font and Text view also has another method to apply a bold font weight to the text, bold().
```swift

Text("Hello, world!")
    .font(
        .system(size: 34)
    )
    .bold()

Text("Hello, world!")
    .font(
        .system(size: 34)
        .bold()

    )

    
```
Set font-weight with weight(_:) modifier

Set font-weight via weight(_:) modifier. This is a Font instance method, so we use this on a font, not text.

```swift

Text("Hello, world!")
    .font(.largeTitle)
Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)

    )
Text("Hello, world!")
    .font(
        .system(
            .largeTitle,
            design: .rounded
        )
        .weight(.light)

    )
Text("Hello, world!")
    .font(
        .system(size: 34)
        .weight(.heavy)

    )
```

How to change SwiftUI font Color

We can set text color via a Text view modifier, foregroundColor(_:).
```swift

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.pink)

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.orange)

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.yellow)
```

**Relative size on custom font:**
To make a custom font scale with the same scaling factor as Apple text style, we use Font.custom(_:size:relativeTo:) method. more here: https://sarunw.com/posts/how-to-change-swiftui-font-size/

Here is an example where I use custom font with the same size and use the same scale factor as Apple text style.

```swift

VStack {
    Text("Large Title")
        .font(.custom(
            "AmericanTypewriter",
            size: 34,
            relativeTo: .largeTitle))
    Text("Title 1")
        .font(.custom(
            "AmericanTypewriter",
            size: 28,
            relativeTo: .title))
    Text("Title 2")
        .font(.custom(
            "AmericanTypewriter",
            size: 22,
            relativeTo: .title2))
    Text("Title 3")
        .font(.custom(
            "AmericanTypewriter",
            size: 20,
            relativeTo: .title3))
    Text("Body")
        .font(.custom(
            "AmericanTypewriter",
            size: 17,
            relativeTo: .body))
}
```

### ‚≠ê Layout protocol (AutoLayout via stack in swiftUI):
Ref: https://sarunw.com/posts/swiftui-custom-layout/

The first method we need to implement is sizeThatFits(proposal:subviews:cache:). We need to calculate and report how large the layout container is.

Available space that the container is given. We get this from the proposal parameter.
The size of the container's subviews. We can access this information through the subview proxy getting from the subviews parameter.

```swift
struct BackslashStack: Layout { // A custom Stack
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        // Calculate and return the size of the layout container.
         print(proposal.width)
        // 100
        print(proposal.height)
        // 100
        let subviewSizes = subviews.map { proxy in
            return proxy.sizeThatFits(.unspecified)
        }
        // 2
        let combinedSize = subviewSizes.reduce(.zero) { currentSize, subviewSize in
            return CGSize(
                width: currentSize.width + subviewSize.width,
                height: currentSize.height + subviewSize.height)
        }
        
        // 3
        return combinedSize
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        // Tell each subview where to appear.
         // 1
        let subviewSizes = subviews.map { proxy in
            return proxy.sizeThatFits(.unspecified)
        }
        
        // 2
        var x = bounds.minX
        var y = bounds.minY
        
        // 3
        for index in subviews.indices {
            let subviewSize = subviewSizes[index]
            let sizeProposal = ProposedViewSize(
                width: subviewSize.width,
                height: subviewSize.height)
            
            // 4
            subviews[index]
                .place(
                    at: CGPoint(x: x, y: y),
                    anchor: .topLeading,
                    proposal: sizeProposal
                )

            // 5
            x += subviewSize.width
            y += subviewSize.height
        }
    }
}
```

We have three ways to ask for subview size.

- The zero proposal; respond with the layout's minimum size.
- The infinity proposal; respond with the layout's maximum size.
- The unspecified proposal; respond with the layout's ideal size.

### Lists:
- List styles: https://sarunw.com/posts/swiftui-list-style/
- adjusting list row seperator insets (horizontal): https://sarunw.com/posts/swiftui-list-row-separator-insets/
- remove row seperator: https://sarunw.com/posts/swiftui-list-section-separator-visibility/
https://developer.apple.com/documentation/swiftui/lists
- Hide row seperator: https://sarunw.com/posts/swiftui-list-row-separator-visibility/
- Content inset for scrollview and list: https://sarunw.com/posts/how-to-set-contentinsets-in-swiftui/
- Content inset on the scrollview: https://sarunw.com/posts/what-is-contentinset-in-scrollable-content/
- Cell with link: https://sarunw.com/posts/swiftui-open-url/
- remove first row seperator: https://sarunw.com/posts/swiftui-list-remove-first-separator/
- hidelast seperator: https://sarunw.com/posts/swiftui-list-remove-last-separator/
- Scrollable list: https://sarunw.com/posts/how-to-use-scrollview-in-swiftui/
- Simple list from array of items adhering to identifiable protocol: https://sarunw.com/posts/swiftui-list-from-array/

### Subviews (ForEach):
ForEach

ForEach is a view that creates an array of views from an underlying collection of data.

You can think of it as a map function that turns an array of data into multiple views.

```swift
struct ContentView: View {
    let contacts = [
        "John",
        "Alice",
        "Bob",
        "Foo",
        "Bar"
    ]
    
    var body: some View {
        ForEach(contacts, id: \.self) { contact in
            Text(contact)
        }
    }
}
// The above code is equivalent to
struct ContentView: View {
    var body: some View {
        Text("John")
        Text("Alice")
        Text("Bob")
        Text("Foo")
        Text("Bar")
    }
}
// We can use ForEach inside a List view.

struct ListForEachExample: View {
    let contacts = [
        "John",
        "Alice",
        "Bob",
        "Foo",
        "Bar"
    ]
    
    var body: some View {
        List {
            ForEach(contacts, id: \.self) { contact in
                Text(contact)
            }
        }
    }
}
```

### Grid:
Grid is almost like flex grid: https://sarunw.com/posts/swiftui-lazyvgrid-lazyhgrid/

### Layout adjustments:
https://developer.apple.com/documentation/swiftui/layout-adjustments

### Custom layouts:
https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui

### Image with background

```swift
struct ContentView: View {
    var body: some View {
        Image(systemName: "calendar")
            .resizable() // not sure what this does
            .frame(width: 50, height: 50)
            .background(Color.red)
            // if we‚Äôre looking to add inner padding that takes a view‚Äôs background into account, we need to apply that padding before adding the background
            .padding()
            .background(Color.blue) // a second .background() modifier after the call to .padding() the second background color will be rendered within the padding itself:
    }
}
```

### Spacer:
Spacer to our stack. When placed within an HStack or VStack, spacers always occupy as much space that they can

```swift
struct ContentView: View {
    var body: some View {
        // HStack(spacing: 15) //  that adds a bit of spacing between its children 
        HStack { // HStack(alignment: .top)
            VStack { //VStack(alignment: .leading)
                CalendarView()
                Spacer()
            }
            // Text("Event title").font(.title)
            Spacer()
        }.padding()
    }
}
```

### @ScaledMetric
In iOS 14, SwiftUI introduced the @ScaledMetric property wrapper. It is a property wrapper that scales a numeric value.

```swift
@ScaledMetric var defaultScaledPadding: CGFloat = 8
// Equals to
@ScaledMetric(relativeTo: .body) var defaultScaledPadding: CGFloat = 8
@ScaledMetric(relativeTo: .largeTitle) var largeTitlePadding: CGFloat = 8
```
The following example uses @ScaledMetric to scale the padding value surrounding a text view.
```swift
struct ScalePaddingExample: View {
    @ScaledMetric var scaledPadding: CGFloat = 8

    
    var body: some View {
        VStack {
            Text("Aliquid doloremque consequatur eum enim non illum repudiandae quo reiciendis sequi veniam distinctio illo saepe repellendus eveniet cumque libero eaque architecto aut cupiditate voluptatem animi est unde qui qui laborum quia et est perspiciatis illo excepturi asperiores aut magnam numquam sit odio quia sunt dolorum commodi voluptas sit dicta eos possimus autem tenetur eum ullam.")
                .font(.body)
                .padding(scaledPadding)

        }        
    }
}
```

### UIKit and swiftui
- ‚≠ê‚≠ê‚≠ê Easily use any UIView in SwiftUI View: Full tutorial (Important concept if we cant do something in SwiftUI etc): https://sarunw.com/posts/uiview-in-swiftui/
- embedding swiftui in a storyboard: https://sarunw.com/posts/swiftui-view-as-uiviewcontroller-in-storyboard/ and https://sarunw.com/posts/swiftui-view-in-uikit-using-uihostingcontroller-subclass/ and https://sarunw.com/posts/swiftui-view-as-uiview-in-storyboard/ and https://sarunw.com/posts/custom-uihostingcontroller/ and https://sarunw.com/posts/swiftui-in-uikit/
- Adding swiftUI view to a UIKIT controller: https://sarunw.com/posts/swiftui-view-as-uiviewcontroller/
- Using UIViewController in swiftUI: https://sarunw.com/posts/uiviewcontroller-in-swiftui/

### ‚≠ê Source of truth (Model)
Every piece of data that you read in your view hierarchy has a source of truth, and it should always have a single source of truth
**@State**

@State is a source of truth designed for use locally in a view. Since it means to use internally in the view, Apple recommends marking it as private to reinforce the idea that @State is own and manage by that view only.

**@Binding** is a suitable tool for any view mean to be reusable, since the view doesn't care where that data comes from; it just knows how to render according to that data. Most standard SwiftUI components using this, e.g. Toggle, TextField, and Slider.
```swift

public struct Toggle<Label>: View {
	public init(
		isOn: Binding<Bool>,
		label: () -> Label
	)
}

public struct TextField: View {
	init(
		_ text: Binding<String>
	)
}
``` 
To put this in use, you initialize your view like this.

```swift
@State var bar: Bool = false
   
var body: some View {
  Toggle("Toggle", isOn: $bar)     
}
``` 
We use $ sign to get Binding from @State, this also come from a help of property wrapper.

Everything we saw so far is considered internal data and event since it happens within a view. @State means to be local/private change within a view. @Binding declares a dependency on the @State. And actions we see so far are originated from a user interact directly with the view.

**ObservableObject protocol**

ObjservableObject is a protocol that SwiftUI provided to expose your object to the SwiftUI as a source of truth. Think of it as a tool to equip your object with a goodness @State get, but this time you manage the persistence storage yourself.

You use this when you want a reference type source of truth, which is great for the model you already have.

```swift
class Foo: ObservableObject {
  @Published var show = false
}
// The above example translate to something like this.
class Bar: ObservableObject {
  let objectWillChange = PassthroughSubject<Void, Never>()
   
  var show = false {
    willSet {
      objectWillChange.send()
    }
  }
}
```
You conform your class to ObservableObject protocol and put @Published property wrapper on a variable that you want to keep track of the change. That's all you need to do to make your existing class working in SwiftUI.

@ObservedObject

Just like we declare a dependency on @State with @Binding, we use @ObservedObject to declare a dependency on ObservableObject.

You use it just like @Binding. The only difference is you use @ObservedObject with an ObservableObject. Which is suitable for the view that depends on a model object.

```swift
struct MyView: View {
	@ObservedObject var model: MyModelObject
}
```

MyView(model: modelInstance)
You can also get Binding from an individual property of ObservableObject with the following syntax.

`$model.property`

Which you can use with @Binding.

```swift
var body: some View {
  Toggle("Toggle", isOn: $model.booleanProperty)     
}
```
**@EnvironmentObject**

@EnvironmentObject is just another way of declaring a dependency on ObservableObject, but this time indirectly. With @ObservedObject you have to pass your data around hop by hop, which might feel cumbersome in some cases where that model might need to be consumed in many places. With@EnvironmentObject, you can inject that data from any ancestor view.

The downside of this is it won't be obvious on what ObservableObject needs to be set. To figure it out, you might need to go through the view hierarchy to see which object is needed for @EnvironmentObject. Failing to do this might cause run time error where @EnvironmentObject is not correctly set.

`contentView.environmentObject(foo)`
The entire hierarchy of contentView can access foo data by declare @EnvironmentObject

```swift
struct SomeViewDownTheHeirarchy: View {
    @EnvironmentObject var foo: Foo
    ...
}
```

SwiftUI also provided many environment values[4] you use, e.g., colorScheme, locale, sizeCategory. There might be a time when you need to adjust your view based on these values. When you want to do that, you can use @Environment property wrapper to reads a value from the view‚Äôs environment.

Usage

```swift
struct ContentView: View {
  @Environment(\.colorScheme) var colorScheme
	...
}
``` 

You can override this environment value by injecting it to any view just like @EnvironmentObject, and the entire view hierarchy will get that effect.

// An example to force view to be dark mode
`contentView.environment(\.colorScheme, .dark)`


### Binding:
@Binding is a Property Wrapper. You can think of it as a getter and setter of an underlying storage.

By default, the compiler synthesizes storage for the instance of the property wrapper by prefixing the name with an underscore (_).

So, if we have a property wrapper named @Binding var isAccepted: Bool, the compiler will synthesize the storage with the name _isAccepted. And the storage type of @Binding is Binding<T>.

In summary

Binding<Bool> is a type for underlying storage of @Binding.
This storage is named _isAccepted.
So to properly initialize it, we directly assign Binding<Bool> to the storage _isAccepted.
```swift
init(message: String, isAccepted: Binding<Bool>) {
    self.message = message
    self._isAccepted = isAccepted

}
```

### LifeCycle in SwiftUI
The closest SwiftUI's methods we have are onAppear() and onDisappear() which is equivalents to UIKit's viewDidAppear() and viewDidDisappear().
Creating our own viewDidLoad .modifier: https://sarunw.com/posts/swiftui-viewdidload/

### Boilerplate swiftUI iOS app:
The following is a working SwiftUI app code.
```swift
import SwiftUI
@main
struct SwiftUIApp: App {
    var body: some Scene {
        WindowGroup {
            Text("Hello! SwiftUI")
        }
    }
}
```
And the code above not just works on iOS, but the same code can make an iPad and Mac app. You can write a multiplatform app entirely with SwiftUI. Seem like the concepts of SwiftUI are far more powerful than I first thought.

### Gotchas:
- SwiftUI was built around two data principles. **Data dependency and a single source of truth**. Every time you read a piece of data in your view, you create a dependency for that view. The view depends on the data because every time the data changes, the view has to changes to reflect the new value.
- Declarative UI: SwiftUI said to be declarative UI. It has a way to declare all principles we learn in this declarative world. We can declare data as a source of truth or dependency, and view as a function of those data. SwiftUI will do take care of the rest for us.
- Source of truth: Every piece of data that you read in your view hierarchy has a source of truth, and it should always have a single source of truth
- add  .ignoresSafeArea() to use the full view for a background
- Previews allow you to unit test your views. 
- Previews help you avoid issues when your app is running in dark or landscape mode or on different devices.
- ‚≠ê Pinning views: In the bottom-left corner of the preview area, there‚Äôs a pin button. Pressing this ‚Äúpins‚Äù the current preview so that it‚Äôs still shown when you browse to the code for other views:
- Previewprovider can populate views to quickly test them. Sort of on demand uitesting
- You can have multiple previews. one for ipad, one for ios one for mac in swiftui, or dark, lightmode
- @AppStorage is UserDefault in swiftUI: (has array support) https://stackoverflow.com/a/62563773
- Keeping view code separate from the controller layer makes it also more straightforward to create previews.
- bindings and observable objects are core concepts of SWIFTUI
- SwiftUI can use any UIKit class, including collection views.
So, while it's technically accurate that SwiftUI does not have those features, you can still use them in any SwiftUI app. All you need to do is
use the UIViewRepresentable and UIViewControllerRepresentable
protocols. These allow you to wrap any UIKit component in a SwiftUI
view.
- Opaque result types are responsible for that strange some keyword you see before the return type of a view body.
Opaque types allow you to use protocols as types for properties and
functions, which was not previously possible.
- In a way, opaque types are the opposite of generics. While generics
can specify constraints on types, a generic is always resolved to a concrete type when you use it. So, a caller always needs to specify a type
for a generic explicitly. For example, the array structure is generic, but
you can only create arrays of specific types, like integers, strings, etc.
Opaque types allow you to hide the nature of a returned value. All the
caller knows about an opaque type is that it conforms to a specific protocol and nothing else. 
-  Property wrappers, allow the @State, @Binding, @ObservedObject, @Environment and @EmvironmentObject modifiers you see in
SwiftUI code.
Property wrappers are a powerful feature that allows you to attach custom code to any stored property. This means that each of the property
wrappers of SwiftUI I listed above defines a different, custom behavior. 



### Tips:
- To print in a view stack: `let _ = { Swift.print("hello world") }()`
- when importing code from UIKit. Try to limit the import import UIKit.UIImage
- Animating layout in swiftUI: https://sarunw.com/posts/swiftui-anylayout/ and https://sarunw.com/posts/a-first-look-at-matchedgeometryeffect/ and https://sarunw.com/posts/animation-delay-and-repeatforever-in-swiftui/ and https://sarunw.com/posts/swiftui-animation/
- you can apply a textstyle to every item in a stack by targeting the stack
```swift
VStack {
            TextField("Username", text: $username)                
            TextField("Full name", text: $fullName)
        }.textFieldStyle(RoundedBorderTextFieldStyle())
```

### Resources:
- Performant scrollable stacks: https://developer.apple.com/documentation/swiftui/creating-performant-scrollable-stacks
- mvc and mvvm in swiftui: https://matteomanferdini.com/wp-content/uploads/2020/05/Architecting-SwiftUI-apps-with-MVC-and-MVVM.pdf
- Nice swiftui gotchas: https://matteomanferdini.com/wp-content/uploads/2019/10/The-5-most-common-misconceptions-about-SwiftUI-Matteo-Manferdini.pdf
- very simple List based (master / detail) app with tab-bar: https://github.com/roman-luzgin/BlogAppSwiftUI (tut on medium)
- Sticky header section in SwiftUI grid: https://yoswift.dev/swiftui/pinnedScrollableViews/
- Customize TagBar https://sarunw.com/posts/swiftui-tabbaritem-color/
- ForEach: https://sarunw.com/posts/swiftui-foreach/
- KeyPath: https://sarunw.com/posts/what-is-keypath-in-swift/
- ZIndex in swiftUI: https://sarunw.com/posts/swiftui-zindex/
- Gauge (Progress UI) https://sarunw.com/posts/swiftui-gauge/
- ‚≠ê ViewThatFits (A responsive problem solver view) https://sarunw.com/posts/swiftui-viewthatfits/
- Bottom sheets: https://sarunw.com/posts/swiftui-bottom-sheet/
- Text linelimit: https://sarunw.com/posts/swiftui-text-linelimit/
- Multiline TextField: https://sarunw.com/posts/swiftui-multiline-textfield/
- Grid (comprehensive) https://sarunw.com/posts/swiftui-grid/ and https://sarunw.com/posts/swiftui-lazyvgrid-lazyhgrid/
- Divider component: https://sarunw.com/posts/swiftui-divider/
- customize label class: https://sarunw.com/posts/how-to-use-label-in-swiftui-custom-view/
- Drawing path in swiftui: https://sarunw.com/posts/how-to-draw-custom-paths-and-shapes-in-swiftui/
- Aligning text horizontally and vertically: https://sarunw.com/posts/how-to-align-text-in-swiftui/
- refreshable to list: https://sarunw.com/posts/pull-to-refresh-in-swiftui/
- screen background color: https://sarunw.com/posts/how-to-set-screen-background-color-in-swiftui/
- Demystifying ScrollView: https://sarunw.com/posts/list-view-uitableview-equivalent-in-swiftui/
- ForEach Demystifying: https://sarunw.com/posts/create-list-of-views-in-swiftui-using-foreach/
- Bottom toolbar component: https://sarunw.com/posts/uitoolbar-in-swiftui/
- Add custom components to xcode library (drag them into preview after) https://sarunw.com/posts/add-custom-swiftui-view-to-view-library/
- Greate SwiftUI resource: https://www.swiftbysundell.com/tags/swiftui/
- Charts: https://medium.com/@sharma17krups/swiftui-charts-7d73262150a1

### SwiftUI xcode shortcuts:
- To trigger refresh canvas `Press command + option + p keys.`
- Re-Indent: `‚åÉ ‚Äì control + i` or Editor menu > Structure > Re-Indent
- To move line of code up: `‚åò - command + ‚å• - option + [` or Editor menu > Structure > Move Line Up
- To move line of code down: `‚åò - command + ‚å• - option + ]` or Editor menu > Structure > Move Line Down
- To toggle SwiftUI Preview, you use this shortcut: `‚åò - command + ‚å•` - option + ‚èé Return or Editor menu > Canvas
- Toggle Canvas / SwiftUI Preview ( ‚å• + ‚åò + ‚Ü© ) üëâ (alt + cmd + enter)
- "paint" multi-selection: alt+shift + drag mouse

### Todo
- try to popup a sheet: see bottom here: https://matteomanferdini.com/swiftui/
- make index of this markdown file, Use AI