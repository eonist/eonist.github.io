My notes on swiftUI<!--more-->

### SwiftUI Key concepts

- In imperative programming, you write a series of statements to describe how your program works.

- a declarative paradigm, where you state what your program does instead of how it works. This works exceptionally well for building user interfaces,

- User interfaces in SwiftUI are made of view structures
SwiftUI interfaces are made of views. This idea is not new and comes from the MVC pattern. In short, the role of a view is to show information to the user and enable interaction.

- The first is the some keyword in the return type of the body property. That’s an opaque result type, a feature introduced in Swift 5.1. It allows you to hide the returned value behind the View protocol. All you need to know about opaque types, for now, is that they make it easier to write and change SwiftUI code.

- We can’t merely put views together in the body property. If you try to list views one after another, the compiler will complain.

- To layout views and compose structured interfaces, you have to use stacks. SwiftUI offers three:
1. HStack for horizontal arrangements,
2. VStack to arrange views vertically, and
3. ZStack, to overlay views in front of each other.

### Steps when building a SwiftUI app:
1. Planning a Paged App
2. Prototyping the Main View
3. Prototyping Supplementary Views
4. Moving Data Between Views
5. Observing Objects
6. Saving Settings
7. Saving History Data
8. Refining Your App
9. Working With Datasets
10. Managing Data With Property Wrappers



```swift
struct Row: View {
	var body: some View {
		HStack() {
			Image("Alita")
			VStack {
				Text("Alita: Battle Angel")
				Text("Robert Rodriguez")
				Text("Action, Adventure, Sci-Fi, Thriller")
				Text("122 min")
			}
		}
	}
}
```

You create previews in code as you do for SwiftUI views. Any time you create a new SwiftUI view file in Xcode, you get the preview code for free in the template. You can then see the result in the Xcode canvas, which you can bring out using the Adjust Editor Options menu.

```swift
// it's a common practice to put preview code in debug fencing:
#if DEBUG
struct Row_Previews: PreviewProvider {
    static var previews: some View {
        Row()
    }
}
#endif
```

### Dataflow in swiftui:
https://sarunw.com/posts/data-in-swiftui-1/
https://sarunw.com/posts/data-in-swiftui-2/
https://sarunw.com/posts/data-in-swiftui-3/

### SwiftUI in a nutshel:

The basic SwiftUI app looks like this (state / binding): 


```swift

struct ContentView: View {
    // 1
    @State private var isPresented = false // parent state
    var body: some View {
        Button("Detail") {
            isPresented = true
        }
        .sheet(isPresented: $isPresented) {
            // 2
            DetailView(isPresented: $isPresented)
        }
    }
}
struct DetailView: View {
    // 1
    @Binding var isPresented: Bool // child state that is connected to parent state via behind the scene default initiator
    var body: some View {
        Button("Back to Main") {
            // 2
            isPresented = false
        }
    }
}
```
ref: https://sarunw.com/posts/swiftui-dismiss-sheet/

### Modifiers
Modifiers are another part of the declarative syntax of SwiftUI that might seem puzzling at first. In imperative Swift code, we cannot append methods one after the other. SwiftUI makes it possible by using an advanced technique called method chaining.


You can also add new views directly to a preview by dragging them from the Library, which you bring up by clicking on the plus button in the Xcode toolbar.

When you want to apply the same modifiers to more than one view, you can use a Group. The modifiers will be applied to all the contained views.

In SwiftUI, layouts are centered by default. We can control the layout of stacks, but only perpendicularly to their axis. If instead, you want to move elements along the axis of a stack, you need to use one or more Spacer views.

**Frame modifier**
To make a SwiftUI view take all available width, we use .frame() modifier with maxWidth and maxHeight set to .infinity.
```swift
.frame(maxWidth: .infinity, maxHeight: .infinity)
```

``` swift
Text("Hello, SwiftUI!")
    .font(.headline)
    // 1
    .border(Color.pink)
```

Make a text view fill its container width with frame modifier

```swift
Text("Hello, SwiftUI!")
    .background(Color.orange) // only behind text
    .font(.headline)
    .border(Color.pink)
    //.frame(maxWidth: .infinity)
    // .frame(maxWidth: .infinity, alignment: .leading) // left aligned
    // .frame(maxWidth: .infinity, alignment: .trailing) // right aligned
    // .background(Color.indigo) // behind frame
    .frame(
        maxWidth: .infinity,
        maxHeight: .infinity

    ) // To make a view taking full height, instead of setting maxWidth to .infinity, we set maxHeight to .infinity.
    .border(Color.blue)
```

This is an excellent opportunity to show you all the nine alignment positions you can have.

1. .topLeading
2. .top
3. .topTrailing
4. .leading
5. .center
6. .trailing
7. .bottomLeading
8. .bottom
9. .bottomTrailing

### Button style
```swift
struct ContentView: View {
    var body: some View {
        VStack {
            Button("Plain", action: {
            }).buttonStyle(PlainButtonStyle())

            Button("Borderless", action: {
            }).buttonStyle(BorderlessButtonStyle())

            Button("Default", action: {
            }).buttonStyle(DefaultButtonStyle())
        }
    }
}
```
For macOS, we have more options, PlainButtonStyle, LinkButtonStyle, BorderedButtonStyle, and BorderlessButtonStyle.

### Viewmodifer: 
ViewModifier is a modifier that you apply to a view or another view modifier, producing a different version of the original value.

good primer for viewmodifiers: https://sarunw.com/posts/swiftui-viewmodifier/

### Representable Protocol

Apple provided you with five representable protocol to wrap UIKit/AppKit/WatchKit into SwiftUI.

```
UIKit/AppKit/WatchKit	Protocol
UIView	UIViewRepresentable
NSView	NSViewRepresentable
WKInterfaceObject	WKInterfaceObjectRepresentable
UIViewController	UIViewControllerRepresentable
NSViewController	NSViewControllerRepresentable
```

These protocols have a very same life cycle and methods, with a purpose to bring the reactive capability to UIKit/AppKit/WatchKit (I will use just UIKit in the rest of the post, but everything applies to all three).

```swift
struct ActivityIndicator: UIViewRepresentable {
    
    func makeUIView(context: Context) -> UIActivityIndicatorView {
        let v = UIActivityIndicatorView()
        
        return v
    }
    
    func updateUIView(_ activityIndicator: UIActivityIndicatorView, context: Context) {
        activityIndicator.startAnimating()
    }
}
// Use this view, and you will see the spinning indicator.
struct ContentView : View {
    
    var body: some View {
        ActivityIndicator()        
    }
}
```
You can expose startAnimating and stopAnimating in the form of binding value.
```swift
struct ActivityIndicator: UIViewRepresentable {
    @Binding var isAnimating: Bool
    
    func makeUIView(context: Context) -> UIActivityIndicatorView {
        let v = UIActivityIndicatorView()
        
        return v
    }
    
    func updateUIView(_ activityIndicator: UIActivityIndicatorView, context: Context) {
        if isAnimating {
            activityIndicator.startAnimating()
        } else {
            activityIndicator.stopAnimating()
        }
    }
}
```
more here: https://sarunw.com/posts/uikit-in-swiftui/

### Updating a View:
Here are all types of Data that will trigger a SwiftUI View update.

```
@State
@Binding
@ObservedObject
@StateObject
@EnvironmentObject
@Environment 
@FetchRequest
@AppStorage
@SceneStorage
@Published inside ObservableObject
``` 

More here: https://sarunw.com/posts/how-to-reload-view-in-swiftui/

### @State
- @State wrapper causes a view to re-render whenever it is changed
- @State is designed for local/private changes inside a view, such as a button highlight or any internal view state.
- Think of state as the parent closure handler code, and binding as the closure in the child
- A @State variable means to use internally within a view. Apple suggested we always declare state variables as private.
- Exposing a state variable as we did might cause confusion to a newcomer or even your future self since the state variable can only initialize once.


```swift
struct CounterView: View {
    @State private var count = 0
    var body: some View {
        VStack {
            Text("Counter: \(count)")
            Button("+1") {
                count += 1
            }
        }
    }
}
// We can use it like this.

struct ContentView: View {
    var body: some View {
        CounterView()

            .font(.title)
    }
}
```
**initialize @State variable in an initializer**
Setting a @State variable like this will only work for the very First time. After the @State variable is create and initialize, SwiftUI will make sure it persisted through the lifetime of the view.


```swift
struct CounterView: View {
    @State private var count: Int
    init(count: Int) { // This is what the compiler synthesizes behind the scene.
    // One case that it might not yield the result you expected is when a @State variable is an optional value. self.count = count
        _count = State(initialValue: count)

    }
    var body: some View {
        VStack {
            Text("Counter: \(count)")
            Button("+1") {
                count += 1
            }
        }
    }
}
// Then we can use it like this.
struct ContentView: View {
    var body: some View {
        CounterView(count: 5)
            .font(.title)
    }
}
```
### StateObject:
> StateObject is a like a reactive model for a view
⭐ ref: https://sarunw.com/posts/manually-initialize-stateobject/
```swift
// initialize @StateObject with parameters in SwiftUI
class DashboardViewModel: ObservableObject {
  @Published var greeting: String
  init(name: String) {
    greeting = "Hello, \(name)!"
  }
}
struct DashboardView: View {
  @StateObject private var viewModel: DashboardViewModel
  init(name: String) {
    // A way to set init values to a model with wrappedvalue
    _viewModel = StateObject(wrappedValue: DashboardViewModel(name: name))
  }
  var body: some View {
    Text("Greeting: \(viewModel.greeting)")
  }
}
```
### @Binding
- We use @Binding property wrapper to define an explicit dependency to a source of truth without owning it. With @Binding, you can read and write to any data that bind to your @Binding variable. The framework will make sure its always in sync.
- @Binding is a suitable tool for any view mean to be reusable, since the view doesn't care where that data comes from; it just knows how to render according to that data. Most standard SwiftUI components using this, e.g. Toggle, TextField, and Slider.
 

```swift
public struct Toggle<Label>: View {
	public init(
		isOn: Binding<Bool>,
		label: () -> Label
	)
}

public struct TextField: View {
	init(
		_ text: Binding<String>
	)
}
// We use $ sign to get Binding from @State, this also come from a help of property wrapper.

@State var bar: Bool = false
   
var body: some View {
  Toggle("Toggle", isOn: $bar)     
}
```
More on bindings: https://sarunw.com/posts/binding-initialization/


### Publisher:
- The Publisher is a tool to bridge between the old world and the new world.
- Several Foundation types expose their functionality through publishers, including Timer, NotificationCenter, and URLSession. Combine also provides a built-in publisher for any property that’s compliant with Key-Value Observing.

```swift
struct ListenerView: View {
  @State var text: String = "Placeholder"
   
  var body: some View {
    TextField("Listener", text: $text)
    .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification)) { (output) in
      self.text = "Keyboard will show"
    }
  }
}
```

### @Environment
 One of a mechanism that SwiftUI use to pass data from one view to another. Like a global variable. But reactive. Great for glbal values like colorscheme or darkmode, locale, calender etc. things that can change from a global perspective and needs to propegate down to components.

 define your own custom keys/values and that is what we are going to learn in this article. To define Environment values you need two things.

EnvironmentKey
EnvironmentValues

```swift
private struct SensitiveKey: EnvironmentKey {
    // 1
    static let defaultValue: Bool = false

}
// Once we declare a data type and a key to access it, we introduce this newly create key/value to EnvironmentValues using an extension. We use the key defined in the last section to get and set the value.

extension EnvironmentValues {
    var isSensitive: Bool {
        get { self[SensitiveKey.self] }
        set { self[SensitiveKey.self] = newValue }
    }
}
// After creating a new key and introduce it to environmental values, we have a working environment value that you can set and access like the system-defined one.
struct ContentView: View {
    @Environment(\.isSensitive) var isSensitive
    
    var body: some View {
        Text("Hello")
            .environment(\.isSensitive, true)
    }
}
// You can add a dedicated modifier to make it easier for users to set the new value. To do that we create a new view modifier and wrap .environment(\.isSensitive) inside.

extension View {
    func isSensitive(_ value: Bool) -> some View {
        environment(\.isSensitive, value)
    }
}
// This gives a more concise syntax to override the environment value, just like some system-defined ones such as .font and .colorScheme.

Text("Hello")
    .isSensitive(true)
``` 

### ObservableObject protocol

ObjservableObject is a protocol that SwiftUI provided to expose your object to the SwiftUI as a source of truth. Think of it as a tool to equip your object with a goodness @State get, but this time you manage the persistence storage yourself.

You use this when you want a reference type source of truth, which is great for the model you already have.

```swift
class Foo: ObservableObject {
  @Published var show = false
}
```
You conform your class to ObservableObject protocol and put @Published property wrapper on a variable that you want to keep track of the change. That's all you need to do to make your existing class working in SwiftUI.

Behind the scene, ObservableObject also use Publisher to emit change to interested parties. Like mentioned before, "Publisher is a single abstraction for representing external changes to SwiftUI".


```Swift 
// The above example translate to something like this.
class Bar: ObservableObject {
  let objectWillChange = PassthroughSubject<Void, Never>()
   
  var show = false {
    willSet {
      objectWillChange.send()
    }
  }
}
```
@ObservedObject

Just like we declare a dependency on @State with @Binding, we use @ObservedObject to declare a dependency on ObservableObject.

Usage

You use it just like @Binding. The only difference is you use @ObservedObject with an ObservableObject. Which is suitable for the view that depends on a model object.


```swift
struct MyView: View {
	@ObservedObject var model: MyModelObject

}

MyView(model: modelInstance)
```

You can also get Binding from an individual property of ObservableObject with the following syntax.

`$model.property`

Which you can use with @Binding.

```swift
var body: some View {
  Toggle("Toggle", isOn: $model.booleanProperty)     
}
```

### @EnvironmentObject

@EnvironmentObject is just another way of declaring a dependency on ObservableObject, but this time indirectly. With @ObservedObject you have to pass your data around hop by hop, which might feel cumbersome in some cases where that model might need to be consumed in many places. With@EnvironmentObject, you can inject that data from any ancestor view.

The downside of this is it won't be obvious on what ObservableObject needs to be set. To figure it out, you might need to go through the view hierarchy to see which object is needed for @EnvironmentObject. Failing to do this might cause run time error where @EnvironmentObject is not correctly set.

```swift
contentView.environmentObject(foo)
```

The entire hierarchy of contentView can access foo data by declare @EnvironmentObject

```swift
struct SomeViewDownTheHeirarchy: View {
    @EnvironmentObject var foo: Foo
    ...
}
```

### @Environment

SwiftUI also provided many environment values[4] you use, e.g., colorScheme, locale, sizeCategory. There might be a time when you need to adjust your view based on these values. When you want to do that, you can use @Environment property wrapper to reads a value from the view’s environment

```swift
struct ContentView: View {
  @Environment(\.colorScheme) var colorScheme
	...
}
``` 

You can override this environment value by injecting it to any view just like @EnvironmentObject, and the entire view hierarchy will get that effect.

```swift
// An example to force view to be dark mode
contentView.environment(\.colorScheme, .dark)
```

### Creating table: 
If you come from UIKit, you will appreciate how easy it is to create tables in SwiftUI. Gone are the days of cell prototypes, data sources, and delegates.

Now, all you need to do is create a List view, pass it an array with your data and declare which views to use as rows.



```swift
struct MoviesView: View {
	var body: some View {
		List(TestData.movies, id: \.title) { movie in
			Row(movie: movie)
		}
	}
}


struct MoviesView_Previews: PreviewProvider {
    static var previews: some View {
        MoviesView()
    }
}
struct Row: View {
	let movie: Movie
	
	var body: some View {
		HStack(spacing: 24.0) {
			Image(movie.poster)
				.resizable()
				.frame(width: 70.0, height: 110.0)
				.shadow(color: .gray, radius: 10.0, x: 4.0, y: 4.0)
			VStack(alignment: .leading, spacing: 4.0) {
				Text(movie.title)
					.font(.headline)
				Text(movie.director)
					.font(.subheadline)
				Group {
					Text(movie.genre)
					Text(movie.runtime)
				}
				.font(.caption)
				.foregroundColor(.secondary)
			}
			Spacer()
		}
	}
}

struct Row_Previews: PreviewProvider {
	static var previews: some View {
		Row(movie: TestData.movies[0])
			.padding()
			.previewLayout(.sizeThatFits)
	}
}
```

## adding delete and move:


```swift
struct MoviesView: View {
	@State var movies: [Movie] = TestData.movies
	
	var body: some View {
		List {
			EditButton()
			ForEach (movies, id: \.title) { movie in
				Row(movie: movie)
			}
			.onMove { (source, destination) in
				self.movies.move(fromOffsets: source, toOffset: destination)
			}
			.onDelete { offsets in
				self.movies.remove(atOffsets: offsets)
			}
		}
	}
}
```

First of all, any mutable data in a SwiftUI app needs to be stored in @State and @ObservedObject properties. You can get my free guide on architecting SwiftUI apps with MVC and MVVM to know when to use each.


In SwiftUI, we affect the appearance of views by changing the parameters of initializers and view modifiers.

Whenever a view in SwiftUI needs to update data that resides somewhere else, we use a binding. A binding is a reference that reaches data stored elsewhere, which, in SwiftUI, is called the single source of truth.

`@Binding var movie: Movie` // we pass movie in the init

```swift
Button(action: { self.movie.isFavorite.toggle() }) {
					Heart(isFilled: movie.isFavorite)
						.font(.title)
				}
```

and 

```swift
static let movie = TestData.movies[0]
DetailsView(movie: .constant(movie))
			Group {
				SideInfo(movie: .constant(movie))
				BottomInfo(movie: movie)
			}
// Notice that a $ sign precedes the movie parameter for the SideInfo view. This is a SwiftUI operator you use to connect bindings to data.
SideInfo(movie: $movie)
```

You can connect bindings to @State and @ObservedObject properties, or other bindings, like in this case. These chains of bindings allow us to pass changes up the view hierarchy until we reach the single source of truth. To know more

While the main navigation of an iOS app is managed by architectural views like NavigationView and TabView, modal presentation happens through three view modifiers:

the .alert modifier shows a small alert panel in the middle of the screen, with one or two buttons;
the .actionSheet modifier presents a menu with several options;
the .sheet modifier presents a full-screen view.


### Examples:

```json
[
	{
		"Title":"Alita: Battle Angel",
		"Year":"2019",
		"Runtime":"122 min",
		"Genre":"Action, Adventure, Sci-Fi, Thriller",
		"Director":"Robert Rodriguez",
		"Actors":"Rosa Salazar, Christoph Waltz, Jennifer Connelly, Mahershala Ali",
		"Plot":"A deactivated cyborg is revived, but cannot remember anything of her past life and goes on a quest to find out who she is.",
		"Country":"USA",
		"Awards":"8 wins & 25 nominations.",
		"Poster":"Alita"
	}
]
```

```swift
struct Movie: Decodable {
    let title: String
    let year: String
    let runtime: String
    let genre: String
    let director: String
    let actors: String
    let plot: String
    let country: String
    let awards: String
    let poster: String
}
```

```swift
struct TestData {
	static var movies: [Movie] = {
		let url = Bundle.main.url(forResource: "Movies", withExtension: "json")!
		let data = try! Data(contentsOf: url)
		let decoder = JSONDecoder()
		return try! decoder.decode([Movie].self, from: data)
	}()
}
```

Views that require Bindings
In a chat app, I have a LoginView that updates the username binding that's past from the enclosing view:

```swift
struct LoginView: View {  
   @Binding var username: String
   ...
}
```
The simplest way to create a binding in your preview is to use the constant function:

```swift
struct LoginView_Previews: PreviewProvider {
   static var previews: some View {
       LoginView(username: .constant("Billy"))
   }
}
```

preview cells:

```swift
struct DecisionCell_Previews: PreviewProvider {
   static var previews: some View {
       DecisionCell(
           decision: Decision(handValue: 6, dealerCardValue: .nine, action: .hit), myHandValue: 8, dealerCardValue: .five)
           .previewLayout(.sizeThatFits)
           .padding()
   }
}
```
_PreviewOrientation returns a Group containing the original View in portrait and landscape modes:
```swift
struct _PreviewOrientation<Value: View>: View {
   private let viewToPreview: Value

   init(_ viewToPreview: Value) {
       self.viewToPreview = viewToPreview
   }

   var body: some View {
       Group {
           viewToPreview
           viewToPreview.previewInterfaceOrientation(.landscapeRight)
       }
   }
}
```
To use this view builder in a preview, simply pass in the View you're previewing:
```swift
struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
       _PreviewOrientation(
           ContentView()
       )
   }
}
```

### No device
_PreviewNoDevice returns a view built from adding the previewLayout modifier and adding `padding to the input view:

```swift
struct _PreviewNoDevice<Value: View>: View {
   private let viewToPreview: Value

   init(_ viewToPreview: Value) {
       self.viewToPreview = viewToPreview
   }

   var body: some View {
       Group {
           viewToPreview
               .previewLayout(.sizeThatFits)
               .padding()
       }
   }
}
```
To use this view builder in a preview, simply pass in the View you're previewing:


```swift
struct CardView_Previews: PreviewProvider {
   static var previews: some View {
       _PreviewNoDevice(
           CardView(card: Card())
       )
   }
}
```

### Multiple devices
_PreviewDevices returns a Group containing a copy of the View for each device type. You can modify devices in the code to include the devices you want to see previews for:

```swift
struct _PreviewDevices<Value: View>: View {
   let devices = [
       "iPhone 13 Pro Max",
       "iPhone 13 mini",
       "iPad (9th generation)"
   ]

   private let viewToPreview: Value

   init(_ viewToPreview: Value) {
       self.viewToPreview = viewToPreview
   }

   var body: some View {
       Group {
           ForEach(devices, id: \.self) { device in
               viewToPreview
                   .previewDevice(PreviewDevice(rawValue: device))
                   .previewDisplayName(device)
           }
       }
   }
}
```
I’d be cautious about adding too many devices as it will make any previews using this view builder slow down and consume resources.

To use this view builder in a preview, simply pass in the View you're previewing:

```swift
struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
       _PreviewDevices(
           ContentView()
       )
   }
}
```

### Combining multiple view builders
Each view builder receives a view and returns a new view. That means that you can compose the functions by passing the results of one view builder to another. In the extreme case, you can use up to three on the same view preview:

```swift
struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
       _PreviewOrientation(
           _PreviewColorScheme(
               _PreviewDevices(ContentView())
           )
       )
   }
}
```
This produces 12 views to cover all permutations of orientation, appearance, and device.

For each view, you should consider which modifiers add value. For the CardView, it makes sense to use _PreviewNoDevice and _PreviewColorSchem e, but previewing on different devices and orientations wouldn't add any value.

### Adding coredata to swiftUI
https://betterprogramming.pub/how-to-make-a-task-list-using-swiftui-and-core-data-a8ab6eaf0f58
```swift 

struct ContentView: View {
    @Environment(\.managedObjectContext) var context
    // this is the variable we added
    @State private var taskName: String = ""
    var body: some View {
        // this is the TextField that we added
        TextField("Task Name", text: $taskName)
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
var body: some View {
    HStack{
        TextField("Task Name", text: $taskName)
        Button(action: {
            self.addTask()
        }){
            Text("Add Task")
        }
    }
}
func addTask() {
    let newTask = Task(context: context)
    newTask.id = UUID()
    newTask.isComplete = false
    newTask.name = taskName
    newTask.dateAdded = Date()
    do {
        try context.save()
    } catch {
        print(error)
    }
}
func updateTask(_ task: task) {
    let isComplete = true
    let taskID = task.id! as NSUUID
    let fetchRequest: NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = NSPredicate(format: "id == %@", taskID as CVarArg)
    fetchRequest.fetchLimit = 1
    do {
        let test = try context.fetch(fetchRequest)
        let taskUpdate = test[0] as! NSManagedObject
        taskUpdate.setValue(isComplete, forKey: "isComplete")
    } catch {
        print(error)
    }
}

 
```

### A simple tab-bar app:
https://heyjaywilson.medium.com/use-enums-for-tags-in-swiftui-1c3ce349d92c
```swift
import SwiftUI

struct ContentView: View {
   @State private var selection = Tabs.inbox
   
   private enum Tabs: Hashable {
      case inbox
      case projects
      case settings
   }
   
   var body: some View {
      TabView(selection: $selection){
         Text("This will be inbox")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "tray.fill")
                  Text("Inbox")
               }
            }
            .tag(Tabs.inbox)
         Text("This will be projects")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "folder.fill")
                  Text("Projects")
               }
            }
            .tag(Tabs.projects)
         Text("This will be settings")
            .font(.title)
            .tabItem {
               VStack {
                  Image(systemName: "gear")
                  Text("Settings")
               }
            }
            .tag(Tabs.settings)
      }
   }
}

struct ContentView_Previews: PreviewProvider {
   static var previews: some View {
      ContentView()
   }
}

```


### Grid

From iOS 16 Grid and GridRow

https://developer.apple.com/documentation/swiftui/grid

and another grid example:   

https://stackoverflow.com/a/77249313

```swift
struct GridTextView: View {
        var rowData: [RowData] = RowData.sample
        var body: some View {
            Grid(alignment: .leading) {
                Text("Some sort of title")
                ForEach(RowData.sample) { row in
                    GridRow {
                        Text(row.id)
                        Text(row.name)
                            .gridCellColumns(2)
                    }
                }
                GridRow {
                    let row = RowData.sample.first!
                    Text(row.id)
                    Text(row.name)
                    Text("Third extra column")
                }
            }
            .padding()
        }
    }
    
    struct RowData: Identifiable {
        var id: String
        var name: String
        static var sample: [Self] = [.init(id: "1", name: "Joe Doe"), .init(id: "10000", name: "Diana Snow")]
    }
```
```swift

Grid {
    GridRow {
        Text("Row 1")
        ForEach(0..<2) { _ in Color.red }
    }
    GridRow {
        Text("Row 2")
        ForEach(0..<5) { _ in Color.green }
    }
    GridRow {
        Text("Row 3")
        ForEach(0..<4) { _ in Color.blue }
    }
}
```

customize the grid: 
```swift
Grid(alignment: .bottom, horizontalSpacing: 1, verticalSpacing: 1) {

}
```
Performance considerations
A grid can size its rows and columns correctly because it renders all of its child views immediately. If your app exhibits poor performance when it first displays a large grid that appears inside a ScrollView, consider switching to a LazyVGrid or LazyHGrid instead.

Lazy grids render their cells when SwiftUI needs to display them, rather than all at once. This reduces the initial cost of displaying a large scrollable grid that’s never fully visible, but also reduces the grid’s ability to optimally lay out cells. Switch to a lazy grid only if profiling your code shows a worthwhile performance improvement.

https://developer.apple.com/documentation/swiftui/lazyvgrid

```swift
struct VerticalSmileys: View {
    let columns = [GridItem(.flexible()), GridItem(.flexible())]


    var body: some View {
         ScrollView {
             LazyVGrid(columns: columns) {
                 ForEach(0x1f600...0x1f679, id: \.self) { value in
                     Text(String(format: "%x", value))
                     Text(emoji(value))
                         .font(.largeTitle)
                 }
             }
         }
    }


    private func emoji(_ value: Int) -> String {
        guard let scalar = UnicodeScalar(value) else { return "?" }
        return String(Character(scalar))
    }
}
```


### LazyVStack:

https://developer.apple.com/documentation/swiftui/lazyvstack

```swift
ScrollView {
    LazyVStack(alignment: .leading) {
        ForEach(1...100, id: \.self) {
            Text("Row \($0)")
        }
    }
}
// There is also LazyHStack
ScrollView(.horizontal) {
    LazyHStack(alignment: .top, spacing: 10) {
        ForEach(1...100, id: \.self) {
            Text("Column \($0)")
        }
    }
}
```

### Section:
To group content or data inside a lazy stack view, use Section instances as containers for collections of grouped views. Section views don’t have any visual representation themselves but can contain header and footer views that can either scroll with the stack’s content or that you can pin to the top or bottom of the ScrollView.

Note

Use Section views to get platform-appropriate grouping inside stack views or lazy stacks, lazy grids, List, CommandMenu, Form, and several other container types.
```swift 
struct ColorData: Identifiable {
    let id = UUID()
    let name: String
    let color: Color
    let variations: [ShadeData]


    struct ShadeData: Identifiable {
        let id = UUID()
        var brightness: Double
    }


    init(color: Color, name: String) {
        self.name = name
        self.color = color
        self.variations = stride(from: 0.0, to: 0.5, by: 0.1)
            .map { ShadeData(brightness: $0) }
    }
}
```
```swift
struct ColorSelectionView: View {
    let sections = [
        ColorData(color: .red, name: "Reds"),
        ColorData(color: .green, name: "Greens"),
        ColorData(color: .blue, name: "Blues")
    ]


    var body: some View {
        ScrollView {
            LazyVStack(spacing: 1) {
                ForEach(sections) { section in
                    Section(header: SectionHeaderView(colorData: section)) {
                        ForEach(section.variations) { variation in
                            section.color
                                .brightness(variation.brightness)
                                .frame(height: 20)
                        }
                    }
                }
            }
        }
    }
}
```

For header and footer view: https://developer.apple.com/documentation/swiftui/grouping-data-with-lazy-stack-views

### navigationStacks: 
In iOS 16, Apple did a big revamp on the navigation view architecture. They deprecated the NavigationView and replaced it with the NavigationStack.

https://sarunw.com/posts/how-to-pop-view-from-navigation-stack-in-swiftui/

### Form: 
A list that is meant as input: https://sarunw.com/posts/swiftui-form/

### Stacks:
Equal height hstacks: https://sarunw.com/posts/swiftui-equal-height-hstack/

### ⭐ Sizing in SwiftUI (very important):
- ⭐ ideal size / intrinsic size / fixed size: https://sarunw.com/posts/intrinsic-content-size-in-swiftui/
- ⭐ FixedSize and ideal size: https://sarunw.com/posts/swiftui-fixedsize/

### Shape:

```swift
Rectangle()
    .fill(Color.pink)
Rectangle()
    .inset(by: 10) // padding
    .fill(Color.pink)
Rectangle()
    .offset(x: 100, y: 100) // offset positioning
    .fill(Color.pink)
Rectangle()
    .scale(0.5)// scale
    .fill(Color.pink)
Rectangle()
    .rotation(.degrees(90)) // rotates the rect
Rectangle()
    // gradient (If you want to rotate the color, use .rotationEffect.)
    .fill(LinearGradient(gradient: Gradient(colors: [.pink, .black]), startPoint: .top, endPoint: .bottom))
Rectangle()
    .stroke(Color.pink)
    .frame(width: 100, height: 100)
Rectangle()
    .stroke(Color.pink, lineWidth: 5)
    .frame(width: 100, height: 100)
Rectangle()
    // draws stroke in the center of rect
    .stroke(Color.pink, style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round))
    .frame(width: 100, height: 100)
Rectangle()
    // within rectange
    .strokeBorder(Color.pink, lineWidth: 20, antialiased: true)
    .frame(width: 100, height: 100)
    .border(Color.blue)
```
More on gradient: https://sarunw.com/posts/gradient-in-swiftui/

### To draw fill and stroke: 
We cant draw and fill in the same rect, because both return view
```swift
ZStack {
    Rectangle()
        .fill(Color.pink)
        .frame(width: 100, height: 100)
    Rectangle()
        .stroke(Color.blue)
        .frame(width: 100, height: 100)
}
Rectangle()
    .fill(Color.pink)
    .frame(width: 100, height: 100)
    .overlay(
        Rectangle()
            .stroke(Color.blue)
)
```

**.trim** 

Draw fractional stroke:

```swift
struct ContentView: View {
    @State private var progress: CGFloat = 0
    
    var body: some View {
        VStack {
            Spacer()
        Rectangle()
            .trim(from: 0, to: progress)
            .stroke(Color.pink)
            .frame(width: 200, height: 200)
        
            Rectangle()
            .trim(from: 0, to: progress)
            .stroke(Color.pink)
            .frame(width: 200, height: 100)
            
            Spacer()
            Text("\(progress)")
            Slider(value: $progress)
        }
    }
}
```

### Font

Using UIFont in swiftUI
```swift
let uiFont = UIFont.systemFont(ofSize: 18, weight: .bold)
// 1
let font = Font(uiFont)
```
Apple encourages us to use built-in text styles whenever possible.
```swift
Text("Hello, world!")
    .font(.largeTitle) //  text style adapts its size based on user text size preference
``` 

There are two ways to set a font size for Text view in SwiftUI.

- Fixed size (Fixed font size stays the same regardless of user preference.) To set fixed font size, we specified the size we wanted at a time when we created a font. We can set this for both the system font and a custom font.
- Dynamic size: Dynamic Type size is a way we describe text size from its usage (text style) instead of the exact point size. Apple has 11 text styles at the moment.
1. Large Title
2. Title 1
3. Title 2
4. Title 3
5. Headline
6. Body
7. Callout
8. Subhead
9. Footnote
10. Caption 1
11. Caption 2


If the text style size doesn't match what your need, you can set a font size by specified when you initialize a font.

Set font size for a system font.
```swift

Text("Hello, world!")
    .font(.system(size: 36))
    
```

Set font size for a custom font. 
```swift
Text("Hello, world!")
    .font(.custom(
        "AmericanTypewriter",
        fixedSize: 36))

```

Note that once you decide to set your font size, you opt out of the benefits of text style automatic sizing based on user prefs. It is possible make relative fontsize: You can also set a size for custom font relative to text style with Font.custom(_:size:). https://sarunw.com/posts/how-to-change-swiftui-font-size/

```swift
Text("Hello, world!")
    .font(.system(.largeTitle, design: .rounded))
If you initialize a fixed-size font, you can set the font design like this:

Text("Hello, world!")
    .font(.system(size: 34, design: .rounded))
``` 

Set font-weight with font initializer

You can set this when you initialize a custom system font.

```swift
Text("Hello, world!")
    .font(
        .system(size: 34, weight: .bold)
    )
```

Set font-weight with fontWeight(_:) modifier

Text view also has a way to modify font-weight. You can set it with fontWeight(_:) modifier.

Since it is a Text instance method, we use this on a text, not a font.

```swift
Text("Hello, world!")
    .font(
        .system(size: 34)
    )
    .fontWeight(.bold)
    
```


Font and Text view also has another method to apply a bold font weight to the text, bold().
```swift

Text("Hello, world!")
    .font(
        .system(size: 34)
    )
    .bold()

Text("Hello, world!")
    .font(
        .system(size: 34)
        .bold()

    )

    
```
Set font-weight with weight(_:) modifier

Set font-weight via weight(_:) modifier. This is a Font instance method, so we use this on a font, not text.

```swift

Text("Hello, world!")
    .font(.largeTitle)
Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)

    )
Text("Hello, world!")
    .font(
        .system(
            .largeTitle,
            design: .rounded
        )
        .weight(.light)

    )
Text("Hello, world!")
    .font(
        .system(size: 34)
        .weight(.heavy)

    )
```

How to change SwiftUI font Color

We can set text color via a Text view modifier, foregroundColor(_:).
```swift

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.pink)

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.orange)

Text("Hello, world!")
    .font(
        .largeTitle
        .weight(.bold)
    )
    .foregroundColor(.yellow)
```

**Relative size on custom font:**
To make a custom font scale with the same scaling factor as Apple text style, we use Font.custom(_:size:relativeTo:) method. more here: https://sarunw.com/posts/how-to-change-swiftui-font-size/

Here is an example where I use custom font with the same size and use the same scale factor as Apple text style.

```swift

VStack {
    Text("Large Title")
        .font(.custom(
            "AmericanTypewriter",
            size: 34,
            relativeTo: .largeTitle))
    Text("Title 1")
        .font(.custom(
            "AmericanTypewriter",
            size: 28,
            relativeTo: .title))
    Text("Title 2")
        .font(.custom(
            "AmericanTypewriter",
            size: 22,
            relativeTo: .title2))
    Text("Title 3")
        .font(.custom(
            "AmericanTypewriter",
            size: 20,
            relativeTo: .title3))
    Text("Body")
        .font(.custom(
            "AmericanTypewriter",
            size: 17,
            relativeTo: .body))
}
```

### ⭐ Layout protocol (AutoLayout via stack in swiftUI):
Ref: https://sarunw.com/posts/swiftui-custom-layout/

The first method we need to implement is sizeThatFits(proposal:subviews:cache:). We need to calculate and report how large the layout container is.

Available space that the container is given. We get this from the proposal parameter.
The size of the container's subviews. We can access this information through the subview proxy getting from the subviews parameter.

```swift
struct BackslashStack: Layout { // A custom Stack
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        // Calculate and return the size of the layout container.
         print(proposal.width)
        // 100
        print(proposal.height)
        // 100
        let subviewSizes = subviews.map { proxy in
            return proxy.sizeThatFits(.unspecified)
        }
        // 2
        let combinedSize = subviewSizes.reduce(.zero) { currentSize, subviewSize in
            return CGSize(
                width: currentSize.width + subviewSize.width,
                height: currentSize.height + subviewSize.height)
        }
        
        // 3
        return combinedSize
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        // Tell each subview where to appear.
         // 1
        let subviewSizes = subviews.map { proxy in
            return proxy.sizeThatFits(.unspecified)
        }
        
        // 2
        var x = bounds.minX
        var y = bounds.minY
        
        // 3
        for index in subviews.indices {
            let subviewSize = subviewSizes[index]
            let sizeProposal = ProposedViewSize(
                width: subviewSize.width,
                height: subviewSize.height)
            
            // 4
            subviews[index]
                .place(
                    at: CGPoint(x: x, y: y),
                    anchor: .topLeading,
                    proposal: sizeProposal
                )

            // 5
            x += subviewSize.width
            y += subviewSize.height
        }
    }
}
```

We have three ways to ask for subview size.

- The zero proposal; respond with the layout's minimum size.
- The infinity proposal; respond with the layout's maximum size.
- The unspecified proposal; respond with the layout's ideal size.

### Lists:
- List styles: https://sarunw.com/posts/swiftui-list-style/
- adjusting list row seperator insets (horizontal): https://sarunw.com/posts/swiftui-list-row-separator-insets/
- remove row seperator: https://sarunw.com/posts/swiftui-list-section-separator-visibility/
https://developer.apple.com/documentation/swiftui/lists
- Hide row seperator: https://sarunw.com/posts/swiftui-list-row-separator-visibility/
- Content inset for scrollview and list: https://sarunw.com/posts/how-to-set-contentinsets-in-swiftui/
- Content inset on the scrollview: https://sarunw.com/posts/what-is-contentinset-in-scrollable-content/
- Cell with link: https://sarunw.com/posts/swiftui-open-url/
- remove first row seperator: https://sarunw.com/posts/swiftui-list-remove-first-separator/
- hidelast seperator: https://sarunw.com/posts/swiftui-list-remove-last-separator/
- Scrollable list: https://sarunw.com/posts/how-to-use-scrollview-in-swiftui/
- Simple list from array of items adhering to identifiable protocol: https://sarunw.com/posts/swiftui-list-from-array/

### Subviews (ForEach):
ForEach

ForEach is a view that creates an array of views from an underlying collection of data.

You can think of it as a map function that turns an array of data into multiple views.

```swift
struct ContentView: View {
    let contacts = [
        "John",
        "Alice",
        "Bob",
        "Foo",
        "Bar"
    ]
    
    var body: some View {
        ForEach(contacts, id: \.self) { contact in
            Text(contact)
        }
    }
}
// The above code is equivalent to
struct ContentView: View {
    var body: some View {
        Text("John")
        Text("Alice")
        Text("Bob")
        Text("Foo")
        Text("Bar")
    }
}
// We can use ForEach inside a List view.

struct ListForEachExample: View {
    let contacts = [
        "John",
        "Alice",
        "Bob",
        "Foo",
        "Bar"
    ]
    
    var body: some View {
        List {
            ForEach(contacts, id: \.self) { contact in
                Text(contact)
            }
        }
    }
}
```

### Grid:
Grid is almost like flex grid: https://sarunw.com/posts/swiftui-lazyvgrid-lazyhgrid/

### Layout adjustments:
https://developer.apple.com/documentation/swiftui/layout-adjustments

### Custom layouts:
https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui

### Image with background

```swift
struct ContentView: View {
    var body: some View {
        Image(systemName: "calendar")
            .resizable() // not sure what this does
            .frame(width: 50, height: 50)
            .background(Color.red)
            // if we’re looking to add inner padding that takes a view’s background into account, we need to apply that padding before adding the background
            .padding()
            .background(Color.blue) // a second .background() modifier after the call to .padding() the second background color will be rendered within the padding itself:
    }
}
```

### Spacer:
Spacer to our stack. When placed within an HStack or VStack, spacers always occupy as much space that they can

```swift
struct ContentView: View {
    var body: some View {
        // HStack(spacing: 15) //  that adds a bit of spacing between its children 
        HStack { // HStack(alignment: .top)
            VStack { //VStack(alignment: .leading)
                CalendarView()
                Spacer()
            }
            // Text("Event title").font(.title)
            Spacer()
        }.padding()
    }
}
```

### @ScaledMetric
In iOS 14, SwiftUI introduced the @ScaledMetric property wrapper. It is a property wrapper that scales a numeric value.

```swift
@ScaledMetric var defaultScaledPadding: CGFloat = 8
// Equals to
@ScaledMetric(relativeTo: .body) var defaultScaledPadding: CGFloat = 8
@ScaledMetric(relativeTo: .largeTitle) var largeTitlePadding: CGFloat = 8
```
The following example uses @ScaledMetric to scale the padding value surrounding a text view.
```swift
struct ScalePaddingExample: View {
    @ScaledMetric var scaledPadding: CGFloat = 8

    
    var body: some View {
        VStack {
            Text("Aliquid doloremque consequatur eum enim non illum repudiandae quo reiciendis sequi veniam distinctio illo saepe repellendus eveniet cumque libero eaque architecto aut cupiditate voluptatem animi est unde qui qui laborum quia et est perspiciatis illo excepturi asperiores aut magnam numquam sit odio quia sunt dolorum commodi voluptas sit dicta eos possimus autem tenetur eum ullam.")
                .font(.body)
                .padding(scaledPadding)

        }        
    }
}
```

### UIKit and swiftui
- ⭐⭐⭐ Easily use any UIView in SwiftUI View: Full tutorial (Important concept if we cant do something in SwiftUI etc): https://sarunw.com/posts/uiview-in-swiftui/
- embedding swiftui in a storyboard: https://sarunw.com/posts/swiftui-view-as-uiviewcontroller-in-storyboard/ and https://sarunw.com/posts/swiftui-view-in-uikit-using-uihostingcontroller-subclass/ and https://sarunw.com/posts/swiftui-view-as-uiview-in-storyboard/ and https://sarunw.com/posts/custom-uihostingcontroller/ and https://sarunw.com/posts/swiftui-in-uikit/
- Adding swiftUI view to a UIKIT controller: https://sarunw.com/posts/swiftui-view-as-uiviewcontroller/
- Using UIViewController in swiftUI: https://sarunw.com/posts/uiviewcontroller-in-swiftui/

### ⭐ Source of truth (Model)
Every piece of data that you read in your view hierarchy has a source of truth, and it should always have a single source of truth
**@State**

@State is a source of truth designed for use locally in a view. Since it means to use internally in the view, Apple recommends marking it as private to reinforce the idea that @State is own and manage by that view only.

**@Binding** is a suitable tool for any view mean to be reusable, since the view doesn't care where that data comes from; it just knows how to render according to that data. Most standard SwiftUI components using this, e.g. Toggle, TextField, and Slider.
```swift

public struct Toggle<Label>: View {
	public init(
		isOn: Binding<Bool>,
		label: () -> Label
	)
}

public struct TextField: View {
	init(
		_ text: Binding<String>
	)
}
``` 
To put this in use, you initialize your view like this.

```swift
@State var bar: Bool = false
   
var body: some View {
  Toggle("Toggle", isOn: $bar)     
}
``` 
We use $ sign to get Binding from @State, this also come from a help of property wrapper.

Everything we saw so far is considered internal data and event since it happens within a view. @State means to be local/private change within a view. @Binding declares a dependency on the @State. And actions we see so far are originated from a user interact directly with the view.

**ObservableObject protocol**

ObjservableObject is a protocol that SwiftUI provided to expose your object to the SwiftUI as a source of truth. Think of it as a tool to equip your object with a goodness @State get, but this time you manage the persistence storage yourself.

You use this when you want a reference type source of truth, which is great for the model you already have.

```swift
class Foo: ObservableObject {
  @Published var show = false
}
// The above example translate to something like this.
class Bar: ObservableObject {
  let objectWillChange = PassthroughSubject<Void, Never>()
   
  var show = false {
    willSet {
      objectWillChange.send()
    }
  }
}
```
You conform your class to ObservableObject protocol and put @Published property wrapper on a variable that you want to keep track of the change. That's all you need to do to make your existing class working in SwiftUI.

@ObservedObject

Just like we declare a dependency on @State with @Binding, we use @ObservedObject to declare a dependency on ObservableObject.

You use it just like @Binding. The only difference is you use @ObservedObject with an ObservableObject. Which is suitable for the view that depends on a model object.

```swift
struct MyView: View {
	@ObservedObject var model: MyModelObject
}
```

MyView(model: modelInstance)
You can also get Binding from an individual property of ObservableObject with the following syntax.

`$model.property`

Which you can use with @Binding.

```swift
var body: some View {
  Toggle("Toggle", isOn: $model.booleanProperty)     
}
```
**@EnvironmentObject**

@EnvironmentObject is just another way of declaring a dependency on ObservableObject, but this time indirectly. With @ObservedObject you have to pass your data around hop by hop, which might feel cumbersome in some cases where that model might need to be consumed in many places. With@EnvironmentObject, you can inject that data from any ancestor view.

The downside of this is it won't be obvious on what ObservableObject needs to be set. To figure it out, you might need to go through the view hierarchy to see which object is needed for @EnvironmentObject. Failing to do this might cause run time error where @EnvironmentObject is not correctly set.

`contentView.environmentObject(foo)`
The entire hierarchy of contentView can access foo data by declare @EnvironmentObject

```swift
struct SomeViewDownTheHeirarchy: View {
    @EnvironmentObject var foo: Foo
    ...
}
```

SwiftUI also provided many environment values[4] you use, e.g., colorScheme, locale, sizeCategory. There might be a time when you need to adjust your view based on these values. When you want to do that, you can use @Environment property wrapper to reads a value from the view’s environment.

Usage

```swift
struct ContentView: View {
  @Environment(\.colorScheme) var colorScheme
	...
}
``` 

You can override this environment value by injecting it to any view just like @EnvironmentObject, and the entire view hierarchy will get that effect.

// An example to force view to be dark mode
`contentView.environment(\.colorScheme, .dark)`


### Binding:
@Binding is a Property Wrapper. You can think of it as a getter and setter of an underlying storage.

By default, the compiler synthesizes storage for the instance of the property wrapper by prefixing the name with an underscore (_).

So, if we have a property wrapper named @Binding var isAccepted: Bool, the compiler will synthesize the storage with the name _isAccepted. And the storage type of @Binding is Binding<T>.

In summary

Binding<Bool> is a type for underlying storage of @Binding.
This storage is named _isAccepted.
So to properly initialize it, we directly assign Binding<Bool> to the storage _isAccepted.
```swift
init(message: String, isAccepted: Binding<Bool>) {
    self.message = message
    self._isAccepted = isAccepted

}
```

### LifeCycle in SwiftUI
The closest SwiftUI's methods we have are onAppear() and onDisappear() which is equivalents to UIKit's viewDidAppear() and viewDidDisappear().
Creating our own viewDidLoad .modifier: https://sarunw.com/posts/swiftui-viewdidload/

### Boilerplate swiftUI iOS app:
The following is a working SwiftUI app code.
```swift
import SwiftUI
@main
struct SwiftUIApp: App {
    var body: some Scene {
        WindowGroup {
            Text("Hello! SwiftUI")
        }
    }
}
```
And the code above not just works on iOS, but the same code can make an iPad and Mac app. You can write a multiplatform app entirely with SwiftUI. Seem like the concepts of SwiftUI are far more powerful than I first thought.

### Gotchas:
- SwiftUI was built around two data principles. **Data dependency and a single source of truth**. Every time you read a piece of data in your view, you create a dependency for that view. The view depends on the data because every time the data changes, the view has to changes to reflect the new value.
- Declarative UI: SwiftUI said to be declarative UI. It has a way to declare all principles we learn in this declarative world. We can declare data as a source of truth or dependency, and view as a function of those data. SwiftUI will do take care of the rest for us.
- Source of truth: Every piece of data that you read in your view hierarchy has a source of truth, and it should always have a single source of truth
- add  .ignoresSafeArea() to use the full view for a background
- Previews allow you to unit test your views. 
- Previews help you avoid issues when your app is running in dark or landscape mode or on different devices.
- ⭐ Pinning views: In the bottom-left corner of the preview area, there’s a pin button. Pressing this “pins” the current preview so that it’s still shown when you browse to the code for other views:
- Previewprovider can populate views to quickly test them. Sort of on demand uitesting
- You can have multiple previews. one for ipad, one for ios one for mac in swiftui, or dark, lightmode
- @AppStorage is UserDefault in swiftUI: https://stackoverflow.com/a/62563773
- Keeping view code separate from the controller layer makes it also more straightforward to create previews.
- bindings and observable objects are core concepts of SWIFTUI
- SwiftUI can use any UIKit class, including collection views.
So, while it's technically accurate that SwiftUI does not have those features, you can still use them in any SwiftUI app. All you need to do is
use the UIViewRepresentable and UIViewControllerRepresentable
protocols. These allow you to wrap any UIKit component in a SwiftUI
view.
- Opaque result types are responsible for that strange some keyword you see before the return type of a view body.
Opaque types allow you to use protocols as types for properties and
functions, which was not previously possible.
- In a way, opaque types are the opposite of generics. While generics
can specify constraints on types, a generic is always resolved to a concrete type when you use it. So, a caller always needs to specify a type
for a generic explicitly. For example, the array structure is generic, but
you can only create arrays of specific types, like integers, strings, etc.
Opaque types allow you to hide the nature of a returned value. All the
caller knows about an opaque type is that it conforms to a specific protocol and nothing else. 
-  Property wrappers, allow the @State, @Binding, @ObservedObject, @Environment and @EmvironmentObject modifiers you see in
SwiftUI code.
Property wrappers are a powerful feature that allows you to attach custom code to any stored property. This means that each of the property
wrappers of SwiftUI I listed above defines a different, custom behavior. 



### Tips:
- when importing code from UIKit. Try to limit the import import UIKit.UIImage
- Animating layout in swiftUI: https://sarunw.com/posts/swiftui-anylayout/ and https://sarunw.com/posts/a-first-look-at-matchedgeometryeffect/ and https://sarunw.com/posts/animation-delay-and-repeatforever-in-swiftui/ and https://sarunw.com/posts/swiftui-animation/
- you can apply a textstyle to every item in a stack by targeting the stack
```swift
VStack {
            TextField("Username", text: $username)                
            TextField("Full name", text: $fullName)
        }.textFieldStyle(RoundedBorderTextFieldStyle())
```

### Resources:
- performant scrollable stacks: https://developer.apple.com/documentation/swiftui/creating-performant-scrollable-stacks
- mvc and mvvm in swiftui: https://matteomanferdini.com/wp-content/uploads/2020/05/Architecting-SwiftUI-apps-with-MVC-and-MVVM.pdf
- Nice swiftui gotchas: https://matteomanferdini.com/wp-content/uploads/2019/10/The-5-most-common-misconceptions-about-SwiftUI-Matteo-Manferdini.pdf
- very simple List based (master / detail) app with tab-bar: https://github.com/roman-luzgin/BlogAppSwiftUI (tut on medium)
- Sticky header section in SwiftUI grid: https://yoswift.dev/swiftui/pinnedScrollableViews/
- Customize TagBar https://sarunw.com/posts/swiftui-tabbaritem-color/
- ForEach: https://sarunw.com/posts/swiftui-foreach/
- KeyPath: https://sarunw.com/posts/what-is-keypath-in-swift/
- ZIndex in swiftUI: https://sarunw.com/posts/swiftui-zindex/
- Gauge (Progress UI) https://sarunw.com/posts/swiftui-gauge/
- ⭐ ViewThatFits (A responsive problem solver view) https://sarunw.com/posts/swiftui-viewthatfits/
- Bottom sheets: https://sarunw.com/posts/swiftui-bottom-sheet/
- Text linelimit: https://sarunw.com/posts/swiftui-text-linelimit/
- Multiline TextField: https://sarunw.com/posts/swiftui-multiline-textfield/
- Grid (comprehensive) https://sarunw.com/posts/swiftui-grid/ and https://sarunw.com/posts/swiftui-lazyvgrid-lazyhgrid/
- Devider component: https://sarunw.com/posts/swiftui-divider/
- customize label class: https://sarunw.com/posts/how-to-use-label-in-swiftui-custom-view/
- Drawing path in swiftui: https://sarunw.com/posts/how-to-draw-custom-paths-and-shapes-in-swiftui/
- Aligning text horizontally and vertically: https://sarunw.com/posts/how-to-align-text-in-swiftui/
- refreshable to list: https://sarunw.com/posts/pull-to-refresh-in-swiftui/
- screen background color: https://sarunw.com/posts/how-to-set-screen-background-color-in-swiftui/
- Demystifying ScrollView: https://sarunw.com/posts/list-view-uitableview-equivalent-in-swiftui/
- ForEach Demystifying: https://sarunw.com/posts/create-list-of-views-in-swiftui-using-foreach/
- Bottom toolbar component: https://sarunw.com/posts/uitoolbar-in-swiftui/
- Add custom components to xcode library (drag them into preview after) https://sarunw.com/posts/add-custom-swiftui-view-to-view-library/
- Greate SwiftUI resource: https://www.swiftbysundell.com/tags/swiftui/

### SwiftUI xcode shortcuts:
-  to trigger refresh canvas `Press command + option + p keys.`
- Re-Indent: `⌃ – control + i` or Editor menu > Structure > Re-Indent
- To move line of code up: `⌘ - command + ⌥ - option + [` or Editor menu > Structure > Move Line Up
- To move line of code down: `⌘ - command + ⌥ - option + ]` or Editor menu > Structure > Move Line Down
- To toggle SwiftUI Preview, you use this shortcut: `⌘ - command + ⌥` - option + ⏎ Return or Editor menu > Canvas

### Todo
- try to popup a sheet: see bottom here: https://matteomanferdini.com/swiftui/
- make index of this markdown file, Use AI